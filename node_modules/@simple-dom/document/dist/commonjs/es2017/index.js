'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

class Node {
    constructor(nodeName, nodeValue) {
        this.nodeName = nodeName;
        this.nodeValue = nodeValue;
        this.parentNode = null;
        this.previousSibling = null;
        this.nextSibling = null;
        this.firstChild = null;
        this.lastChild = null;
        this._childNodes = undefined;
    }
    get childNodes() {
        let children = this._childNodes;
        if (children === undefined) {
            children = this._childNodes = new ChildNodes(this);
        }
        return children;
    }
    cloneNode(deep) {
        const node = this._cloneNode();
        if (deep === true) {
            let child = this.firstChild;
            let nextChild = child;
            while (child !== null) {
                nextChild = child.nextSibling;
                node.appendChild(child.cloneNode(true));
                child = nextChild;
            }
        }
        return node;
    }
    appendChild(newChild) {
        if (newChild.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */) {
            insertFragment(newChild, this, this.lastChild, null);
            return newChild;
        }
        if (newChild.parentNode) {
            newChild.parentNode.removeChild(newChild);
        }
        newChild.parentNode = this;
        const refNode = this.lastChild;
        if (refNode === null) {
            this.firstChild = newChild;
            this.lastChild = newChild;
        }
        else {
            newChild.previousSibling = refNode;
            refNode.nextSibling = newChild;
            this.lastChild = newChild;
        }
        return newChild;
    }
    insertBefore(newChild, refChild) {
        if (refChild == null) {
            return this.appendChild(newChild);
        }
        if (newChild.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */) {
            insertFragment(newChild, this, refChild.previousSibling, refChild);
            return newChild;
        }
        if (newChild.parentNode) {
            newChild.parentNode.removeChild(newChild);
        }
        newChild.parentNode = this;
        const previousSibling = refChild.previousSibling;
        if (previousSibling) {
            previousSibling.nextSibling = newChild;
            newChild.previousSibling = previousSibling;
        }
        else {
            newChild.previousSibling = null;
        }
        refChild.previousSibling = newChild;
        newChild.nextSibling = refChild;
        if (this.firstChild === refChild) {
            this.firstChild = newChild;
        }
        return newChild;
    }
    removeChild(oldChild) {
        if (this.firstChild === oldChild) {
            this.firstChild = oldChild.nextSibling;
        }
        if (this.lastChild === oldChild) {
            this.lastChild = oldChild.previousSibling;
        }
        if (oldChild.previousSibling) {
            oldChild.previousSibling.nextSibling = oldChild.nextSibling;
        }
        if (oldChild.nextSibling) {
            oldChild.nextSibling.previousSibling = oldChild.previousSibling;
        }
        oldChild.parentNode = null;
        oldChild.nextSibling = null;
        oldChild.previousSibling = null;
        return oldChild;
    }
}
function insertFragment(fragment, newParent, before, after) {
    if (!fragment.firstChild) {
        return;
    }
    const firstChild = fragment.firstChild;
    fragment.firstChild = fragment.lastChild = null;
    let lastChild = firstChild;
    let node = firstChild;
    firstChild.previousSibling = before;
    if (before) {
        before.nextSibling = firstChild;
    }
    else {
        newParent.firstChild = firstChild;
    }
    while (node) {
        node.parentNode = newParent;
        lastChild = node;
        node = node.nextSibling;
    }
    lastChild.nextSibling = after;
    if (after) {
        after.previousSibling = lastChild;
    }
    else {
        newParent.lastChild = lastChild;
    }
}
class ChildNodes {
    constructor(node) {
        this.node = node;
    }
    item(index) {
        let child = this.node.firstChild;
        for (let i = 0; child && index !== i; i++) {
            child = child.nextSibling;
        }
        return child;
    }
}

class Element extends Node {
    constructor(tagName) {
        super(tagName.toUpperCase(), null);
        this.nodeType = 1 /* ELEMENT_NODE */;
        this.attributes = [];
    }
    get tagName() {
        return this.nodeName;
    }
    getAttribute(name) {
        const attributes = this.attributes;
        const n = name.toLowerCase();
        let attr;
        for (let i = 0, l = attributes.length; i < l; i++) {
            attr = attributes[i];
            if (attr.name === n) {
                return attr.value;
            }
        }
        return null;
    }
    setAttribute(name, value) {
        const attributes = this.attributes;
        const n = name.toLowerCase();
        let v;
        if (typeof value === 'string') {
            v = value;
        }
        else {
            v = '' + value;
        }
        let attr;
        for (let i = 0, l = attributes.length; i < l; i++) {
            attr = attributes[i];
            if (attr.name === n) {
                attr.value = v;
                return;
            }
        }
        attributes.push({
            name: n,
            specified: true,
            value: v,
        });
    }
    removeAttribute(name) {
        const n = name.toLowerCase();
        const attributes = this.attributes;
        for (let i = 0, l = attributes.length; i < l; i++) {
            const attr = attributes[i];
            if (attr.name === n) {
                attributes.splice(i, 1);
                return;
            }
        }
    }
    _cloneNode() {
        const node = new Element(this.tagName);
        const attrs = node.attributes = [];
        const src = this.attributes;
        for (let i = 0; i < src.length; i++) {
            const attr = src[i];
            attrs.push({ name: attr.name, specified: attr.specified, value: attr.value });
        }
        return node;
    }
}

class DocumentFragment extends Node {
    constructor() {
        super('#document-fragment', null);
        this.nodeType = 11 /* DOCUMENT_FRAGMENT_NODE */;
    }
    _cloneNode() {
        return new DocumentFragment();
    }
}

class Comment extends Node {
    constructor(text) {
        super('#comment', text);
        this.nodeType = 8 /* COMMENT_NODE */;
    }
    _cloneNode() {
        return new Comment(this.nodeValue);
    }
}

class RawHTMLSection extends Node {
    constructor(text) {
        super('#raw-html-section', text);
        this.nodeType = -1 /* RAW */;
    }
    _cloneNode() {
        return new RawHTMLSection(this.nodeValue);
    }
}

class Text extends Node {
    constructor(text) {
        super('#text', text);
        this.nodeType = 3 /* TEXT_NODE */;
    }
    _cloneNode() {
        return new Text(this.nodeValue);
    }
}

class Document extends Node {
    constructor() {
        super('#document', null);
        this.nodeType = 9 /* DOCUMENT_NODE */;
        this.documentElement = new Element('html');
        this.head = new Element('head');
        this.body = new Element('body');
        this.documentElement.appendChild(this.head);
        this.documentElement.appendChild(this.body);
        this.appendChild(this.documentElement);
    }
    createElement(tagName) {
        return new Element(tagName);
    }
    createTextNode(text) {
        return new Text(text);
    }
    createComment(text) {
        return new Comment(text);
    }
    createRawHTMLSection(text) {
        return new RawHTMLSection(text);
    }
    createDocumentFragment() {
        return new DocumentFragment();
    }
    _cloneNode() {
        return new Document();
    }
}

exports.Node = Node;
exports.Element = Element;
exports.DocumentFragment = DocumentFragment;
exports.Document = Document;
//# sourceMappingURL=index.js.map